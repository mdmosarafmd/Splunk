<%
import re
from ta_generator.builder_util import escape_character
%>

<%
customized_vars = [opt for opt in datainput['data_inputs_options'] if opt.get('type') == 'customized_var']
has_customized_var = len(customized_vars) > 0
%>
# encoding = utf-8

import os
import sys
import time
import shlex
import datetime
import subprocess
try:
    import HTMLParser
except ImportError:
    from html import parser as HTMLParser
import mako.template

from splunklib import modularinput as smi

'''
    This file is auto generated by Add-on Builder.
    Do not edit this file!!! It will be overwritten
    by Add-on Builder.
'''
def get_input_arguments():
    arguments = []
    % for data_inputs_option in datainput['data_inputs_options']:
    %   if data_inputs_option.get('type', '') == 'customized_var':
    arguments.append(smi.Argument("${data_inputs_option['name']|escape_character}", title="${data_inputs_option['title']|escape_character}",
                                     description="${re.sub("([\\r\\n]+)", "", data_inputs_option['description']).strip()|escape_character}",
                                     required_on_create=${{1:True,0:False}[data_inputs_option['required_on_create']]},
                                     required_on_edit=False))
    %   endif
    % endfor
    % if not has_customized_var:
    arguments.append(smi.Argument('placeholder', title='Placeholder',
        description='Do not set any value to this', required_on_edit=False, required_on_create=False))
    % endif
    return arguments

def validate_input(helper, definition):
    """overloaded splunklib modularinput method"""
    pass

def collect_events(helper, ew):
    """overloaded splunklib modularinput method"""
    # use simple rest call to load the events
    % for data_inputs_option in datainput['data_inputs_options']:
    % if data_inputs_option['name'] == '_command':
    command = '${data_inputs_option['value']|escape_character}'
    % endif
    % endfor
    input_name = helper.get_input_type()
    stanzas = helper.get_input_stanza()
    for stanza_name, stanza_params in stanzas.items():
        # should unescape the xml text content
        hparser = HTMLParser.HTMLParser()
        input_params = {}
        for k, v in stanza_params.items():
            input_params[k] = '' if v is None else hparser.unescape(str(v))
        stanza_params = input_params

        output_index = stanza_params['index']
        output_sourcetype = stanza_params['sourcetype']

        # parametrization for the command
        temp = mako.template.Template(command)
        translated_command = temp.render(**stanza_params)

        child = subprocess.Popen(translated_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        events = []
        while child.poll() is None:
            content = child.stdout.read()
            if content:
                events.append(content.decode())
        # read the last part of events
        content = child.stdout.read()
        if content:
            events.append(content.decode())

        if events:
            for e in events[:-1]:
                event = helper.new_event(source=input_name, sourcetype=output_sourcetype, index=output_index, data=e, unbroken=True, done=False)
                ew.write_event(event)
            event = helper.new_event(source=input_name, sourcetype=output_sourcetype, index=output_index, data=events[-1], unbroken=True, done=True)
            ew.write_event(event)

        if child.returncode != 0:
            err_prefix = "Command exit code is {}. Fail to run command '{}'.".format(child.returncode, translated_command)
            errmsg = child.stderr.read().decode()
            if errmsg:
                errmsg = err_prefix + "error message:" + errmsg
            else:
                errmsg = err_prefix
            raise RuntimeError(errmsg)
